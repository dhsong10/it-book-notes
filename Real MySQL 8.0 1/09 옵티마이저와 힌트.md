## 09 옵티마이저와 힌트

### MySQL 서버에서 쿼리가 실행되는 과정

MySQL 서버에서 쿼리가 실행될 때에는 다음 세 단계를 거쳐서 이루어진다.

1. SQL 파서는 SQL의 구문을 파싱 해서 **파스 트리**를 만든다. 문법적 오류를 점검한다.
2. 옵티마이저는 생성된 SQL 파스 트리를 통해 최적의 **실행 계획**을 만든다.
3. MySQL엔진과 스토리지 엔진은 실행 계획에 따라서 데이터를 가져온다.

### 옵티마이저의 종류

옵티마이저의 종류는 `비용 기반 최적화(Cost-based optimizer, CBO) 방법`과 `규칙 기반 최적화(Rule-based optimizer, RBO) 방법`이 있다. 현재 대부분의 DBMS는 비용 기반 최적화를 따른다.

`비용 기반 최적화 방법`은 현재 대부분의 DBMS에서 사용하는 방법으로 MySQL도 사용한다. 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만든다. 통계 정보를 사용해서 각 방법으로 쿼리를 실행했을 때의 비용을 산출한다. 가능한 방법 중 비용이 최소인 방법을 실행 계획으로 선택한다.

`규칙 기반 최적화 방법`은 오라클 DBMS에서 사용했던 방법이다. 통계 정보를 이용하지 않고 내장된 우선순위에 따라서 실행 계획을 만든다. 따라서, 같은 쿼리에 대해서는 거의 항상 같은 실행 계획이 선택된다.

### 풀 테이블 스캔

<small style="color: grey;">풀 테이블 스캔 발생 조건</small>

`풀 테이블 스캔`은 인덱스를 사용하지 않고 **테이블의 데이터를 처음부터 끝까지 읽어서** 쿼리를 처리하는 작업을 말한다. 일반적으로 풀 테이블 스캔은 다음과 같은 조건에서 발생한다.

1. 테이블의 **레코드 건수가 적어서** 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 빠른 경우
2. WHERE 절이나 ON 절에서 **인덱스를 이용하는 조건이 없는** 경우
3. 인덱스를 이용하는 조건이 있더라도 옵티마이저가 판단할 때 **일치하는 레코드 건수가 너무 많은** 경우

<small style="color: grey;">리드 어헤드(Read ahead)</small>

풀 테이블 스캔은 테이블의 데이터를 모두 읽기 때문에 디스크 작업이 많다. InnoDB에서는 `리드 어헤드(Read ahead)` 작업을 통해서 많은 디스크 작업에도 불구하고 쿼리를 빠르게 처리할 수 있다. 리드 어헤드는 디스크에서 어떤 영역의 데이터가 앞으로 필요할 것이라고 예측하고, **데이터를 미리 대량으로 읽어서 InnDB의 버퍼 풀에 가져다 두는 작업**이다.

MySQL의 `innodb_read_ahead_threshold` 시스템 변수를 통해 리드 어헤드가 언제부터 동작할지 임곗값을 설정할 수 있다. 시스템 변수에 설정된 개수만큼 연속된 데이터 페이지가 읽히면 리드 어헤드가 동작한다. 리드 어헤드가 동작하면 디스크에서 데이터를 가져오는 작업이 백그라운드 작업으로 전환된다. 백그라운드에서 데이터를 읽을 때 4개 또는 8개씩(최대 64개씩) 페이지를 대량으로 읽어서 InnoDB 버퍼 풀에 가져다 둔다.

<small style="color: grey;">쿼리에 따른 풀 테이블 스캔과 풀 인덱스 스캔</small>

풀 테이블 스캔이 일어나는 경우와 풀 인덱스 스캔이 일어나는 경우는 쿼리에 따라서 달라진다. 인덱스가 아닌 컬럼의 값이 필요한 쿼리라면 풀 테이블 스캔이 발생하지만, 인덱스만으로도 효율적으로 처리할 수 있는 쿼리라면 풀 인덱스 스캔이 발생한다. 풀 인덱스 스캔이 발생하는 대표적인 쿼리는 레코드의 개수를 세는 쿼리이다.

```sql
SELECT COUNT(*) FROM employees; -- 풀 인덱스 스캔
SELECT * FROM employees;        -- 풀 테이블 스캔
``` 

### 병렬 처리

`병렬 처리`는 **하나의 쿼리**를 **여러 스레드가 작업을 나누어서 동시에 처리**하는 작업이다. `innodb_parallel_read_threads` 시스템 변수를 이용해서 하나의 쿼리를 처리할 최대 스레드의 개수를 설정한다. 일반적으로 스레드의 개수가 늘어날수록 쿼리의 실행 시간을 줄어들지만, CPU 코어의 개수를 넘으면 성능이 떨어질 수 있다.

병렬 처리는 MySQL 8.0부터 제한적으로 도입되었다. WHERE 조건이 없는 테이블 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.