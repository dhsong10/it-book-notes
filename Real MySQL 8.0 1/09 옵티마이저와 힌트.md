## 09 옵티마이저와 힌트

### MySQL 서버에서 쿼리가 실행되는 과정

MySQL 서버에서 쿼리가 실행될 때에는 다음 세 단계를 거쳐서 이루어진다.

1. SQL 파서는 SQL의 구문을 파싱 해서 **파스 트리**를 만든다. 문법적 오류를 점검한다.
2. 옵티마이저는 생성된 SQL 파스 트리를 통해 최적의 **실행 계획**을 만든다.
3. MySQL엔진과 스토리지 엔진은 실행 계획에 따라서 데이터를 가져온다.

### 옵티마이저의 종류

옵티마이저의 종류는 `비용 기반 최적화(Cost-based optimizer, CBO) 방법`과 `규칙 기반 최적화(Rule-based optimizer, RBO) 방법`이 있다. 현재 대부분의 DBMS는 비용 기반 최적화를 따른다.

`비용 기반 최적화 방법`은 현재 대부분의 DBMS에서 사용하는 방법으로 MySQL도 사용한다. 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만든다. 통계 정보를 사용해서 각 방법으로 쿼리를 실행했을 때의 비용을 산출한다. 가능한 방법 중 비용이 최소인 방법을 실행 계획으로 선택한다.

`규칙 기반 최적화 방법`은 오라클 DBMS에서 사용했던 방법이다. 통계 정보를 이용하지 않고 내장된 우선순위에 따라서 실행 계획을 만든다. 따라서, 같은 쿼리에 대해서는 거의 항상 같은 실행 계획이 선택된다.

### 풀 테이블 스캔

<small style="color: grey;">풀 테이블 스캔 발생 조건</small>

`풀 테이블 스캔`은 인덱스를 사용하지 않고 **테이블의 데이터를 처음부터 끝까지 읽어서** 쿼리를 처리하는 작업을 말한다. 일반적으로 풀 테이블 스캔은 다음과 같은 조건에서 발생한다.

1. 테이블의 **레코드 건수가 적어서** 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 빠른 경우
2. WHERE 절이나 ON 절에서 **인덱스를 이용하는 조건이 없는** 경우
3. 인덱스를 이용하는 조건이 있더라도 옵티마이저가 판단할 때 **일치하는 레코드 건수가 너무 많은** 경우

<small style="color: grey;">리드 어헤드(Read ahead)</small>

풀 테이블 스캔은 테이블의 데이터를 모두 읽기 때문에 디스크 작업이 많다. InnoDB에서는 `리드 어헤드(Read ahead)` 작업을 통해서 많은 디스크 작업에도 불구하고 쿼리를 빠르게 처리할 수 있다. 리드 어헤드는 디스크에서 어떤 영역의 데이터가 앞으로 필요할 것이라고 예측하고, **데이터를 미리 대량으로 읽어서 InnDB의 버퍼 풀에 가져다 두는 작업**이다.

MySQL의 `innodb_read_ahead_threshold` 시스템 변수를 통해 리드 어헤드가 언제부터 동작할지 임곗값을 설정할 수 있다. 시스템 변수에 설정된 개수만큼 연속된 데이터 페이지가 읽히면 리드 어헤드가 동작한다. 리드 어헤드가 동작하면 디스크에서 데이터를 가져오는 작업이 백그라운드 작업으로 전환된다. 백그라운드에서 데이터를 읽을 때 4개 또는 8개씩(최대 64개씩) 페이지를 대량으로 읽어서 InnoDB 버퍼 풀에 가져다 둔다.

<small style="color: grey;">쿼리에 따른 풀 테이블 스캔과 풀 인덱스 스캔</small>

풀 테이블 스캔이 일어나는 경우와 풀 인덱스 스캔이 일어나는 경우는 쿼리에 따라서 달라진다. 인덱스가 아닌 컬럼의 값이 필요한 쿼리라면 풀 테이블 스캔이 발생하지만, 인덱스만으로도 효율적으로 처리할 수 있는 쿼리라면 풀 인덱스 스캔이 발생한다. 풀 인덱스 스캔이 발생하는 대표적인 쿼리는 레코드의 개수를 세는 쿼리이다.

```sql
SELECT COUNT(*) FROM employees; -- 풀 인덱스 스캔
SELECT * FROM employees;        -- 풀 테이블 스캔
``` 

### 병렬 처리

`병렬 처리`는 **하나의 쿼리**를 **여러 스레드가 작업을 나누어서 동시에 처리**하는 작업이다. `innodb_parallel_read_threads` 시스템 변수를 이용해서 하나의 쿼리를 처리할 최대 스레드의 개수를 설정한다. 일반적으로 스레드의 개수가 늘어날수록 쿼리의 실행 시간을 줄어들지만, CPU 코어의 개수를 넘으면 성능이 떨어질 수 있다.

병렬 처리는 MySQL 8.0부터 제한적으로 도입되었다. WHERE 조건이 없는 테이블 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

### 정렬(ORDER BY) 처리

<small style="color: grey;">정렬 처리 방법 비교</small>

정렬을 처리하는 방법은 `인덱스를 이용한 방법`과 `Filesort를 이용한 방법`으로 구분한다.

`인덱스를 이용한 방법`은 정렬 작업을 빠르게 처리할 수 있다. 인덱스는 정렬된 상태로 디스크에 저장되어 있기 때문이다. 하지만 데이터를 추가, 변경, 삭제할 때 인덱스를 같이 관리해야 한다.

반면 `Filesort를 이용한 방법`은 인덱스에 의존하지 않는다. 모든 정렬 작업이 인덱스를 이용하는 방법으로 처리되지 않는다. 하지만 정렬 작업이 쿼리 실행 시 처리되기 때문에 정렬할 레코드가 많으면 쿼리 응답 속도가 느려진다.

<small style="color: grey;">소트 버퍼(Sort buffer)</small>

`소트 버퍼(Sort buffer)` 정렬 작업을 위해 MySQL이 별도로 할당한 메모리 공간이다. 정렬할 레코드 크기에 따라서 가변적으로 증가하지만 최대 사용 크기는 `sort_buffer_size` 시스템 변수로 설정된다.

메모리(소트 버퍼)의 크기를 넘어서는 데이터를 정렬하기 위해서는 디스크 공간도 활용된다. 소트 버퍼 크기만큼 정렬된 데이터를 디스크에 임시 저장한다. 디스크에 임시 정렬 저장된 데이터를 다시 병합하면서 정렬하는 `멀티 머지(Multi-merge)`를 수행한다. 

메모리(소트 버퍼)의 크기를 키우며 디스크 IO를 줄일 수 있다. 하지만, 성능 상에 큰 이점을 보기는 어렵다. 심지어 메모리(소트 버퍼) 공간이 커지면서 OOM이 발생할 수 있다. 소트 버퍼는 세션 메모리 영역을 사용하기 때문에 모든 커넥션마다 소트 버퍼 메모리 공간이 할당된다. 커넥션이 많아지고 각 커넥션마다 정렬해야 하는 데이터의 크기가 크면, 소트 버퍼의 크기로 인해 서버의 메모리 공간이 부족하게 된다.

<small style="color: grey;">정렬 방식</small>

정렬 방식은 소트 버퍼에 어떠한 레코드가 저장되는지에 따라서 `싱글 패스 방식`과 `투 패스 방식`으로 구분한다.

`싱글 패스 방식`은 소트 버퍼에 **정렬 기준이 되는 칼럼**과 **SELECT 대상이 되는 칼럼 전부**를 저장한다. 따라서 정렬이 이루어진 이후에 소트 버퍼에 있는 레코드를 반환하면 된다.

`투 패스 방식`은 소트 버퍼에 **정렬 기준이 되는 칼럼**과 **프라이머리 키**를 저장한다. 정렬이 이루어진 이후에 프라이머리 키를 가지고 테이블을 다시 조회해서 반환한다. 

최신 버전에서는 일반적으로 싱글 패스 방식을 더 많이 사용한다. 하지만 싱글 패스 방식은 소트 버퍼 크기에 의존적이다. 모든 컬럼(*)을 정렬 조회할 경우 소트 버퍼를 비효율적으로 점유할 가능성이 크다.
