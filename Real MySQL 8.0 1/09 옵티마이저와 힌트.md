## 09 옵티마이저와 힌트

### MySQL 서버에서 쿼리가 실행되는 과정

MySQL 서버에서 쿼리가 실행될 때에는 다음 세 단계를 거쳐서 이루어진다.

1. SQL 파서는 SQL의 구문을 파싱 해서 **파스 트리**를 만든다. 문법적 오류를 점검한다.
2. 옵티마이저는 생성된 SQL 파스 트리를 통해 최적의 **실행 계획**을 만든다.
3. MySQL엔진과 스토리지 엔진은 실행 계획에 따라서 데이터를 가져온다.

### 옵티마이저의 종류

옵티마이저의 종류는 `비용 기반 최적화(Cost-based optimizer, CBO) 방법`과 `규칙 기반 최적화(Rule-based optimizer, RBO) 방법`이 있다. 현재 대부분의 DBMS는 비용 기반 최적화를 따른다.

`비용 기반 최적화 방법`은 현재 대부분의 DBMS에서 사용하는 방법으로 MySQL도 사용한다. 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만든다. 통계 정보를 사용해서 각 방법으로 쿼리를 실행했을 때의 비용을 산출한다. 가능한 방법 중 비용이 최소인 방법을 실행 계획으로 선택한다.

`규칙 기반 최적화 방법`은 오라클 DBMS에서 사용했던 방법이다. 통계 정보를 이용하지 않고 내장된 우선순위에 따라서 실행 계획을 만든다. 따라서, 같은 쿼리에 대해서는 거의 항상 같은 실행 계획이 선택된다.

### 풀 테이블 스캔

<small style="color: grey;">풀 테이블 스캔 발생 조건</small>

`풀 테이블 스캔`은 인덱스를 사용하지 않고 **테이블의 데이터를 처음부터 끝까지 읽어서** 쿼리를 처리하는 작업을 말한다. 일반적으로 풀 테이블 스캔은 다음과 같은 조건에서 발생한다.

1. 테이블의 **레코드 건수가 적어서** 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 빠른 경우
2. WHERE 절이나 ON 절에서 **인덱스를 이용하는 조건이 없는** 경우
3. 인덱스를 이용하는 조건이 있더라도 옵티마이저가 판단할 때 **일치하는 레코드 건수가 너무 많은** 경우

<small style="color: grey;">리드 어헤드(Read ahead)</small>

풀 테이블 스캔은 테이블의 데이터를 모두 읽기 때문에 디스크 작업이 많다. InnoDB에서는 `리드 어헤드(Read ahead)` 작업을 통해서 많은 디스크 작업에도 불구하고 쿼리를 빠르게 처리할 수 있다. 리드 어헤드는 디스크에서 어떤 영역의 데이터가 앞으로 필요할 것이라고 예측하고, **데이터를 미리 대량으로 읽어서 InnDB의 버퍼 풀에 가져다 두는 작업**이다.

MySQL의 `innodb_read_ahead_threshold` 시스템 변수를 통해 리드 어헤드가 언제부터 동작할지 임곗값을 설정할 수 있다. 시스템 변수에 설정된 개수만큼 연속된 데이터 페이지가 읽히면 리드 어헤드가 동작한다. 리드 어헤드가 동작하면 디스크에서 데이터를 가져오는 작업이 백그라운드 작업으로 전환된다. 백그라운드에서 데이터를 읽을 때 4개 또는 8개씩(최대 64개씩) 페이지를 대량으로 읽어서 InnoDB 버퍼 풀에 가져다 둔다.

<small style="color: grey;">쿼리에 따른 풀 테이블 스캔과 풀 인덱스 스캔</small>

풀 테이블 스캔이 일어나는 경우와 풀 인덱스 스캔이 일어나는 경우는 쿼리에 따라서 달라진다. 인덱스가 아닌 칼럼의 값이 필요한 쿼리라면 풀 테이블 스캔이 발생하지만, 인덱스만으로도 효율적으로 처리할 수 있는 쿼리라면 풀 인덱스 스캔이 발생한다. 풀 인덱스 스캔이 발생하는 대표적인 쿼리는 레코드의 개수를 세는 쿼리이다.

```sql
SELECT COUNT(*) FROM employees; -- 풀 인덱스 스캔
SELECT * FROM employees;        -- 풀 테이블 스캔
``` 

### 병렬 처리

`병렬 처리`는 **하나의 쿼리**를 **여러 스레드가 작업을 나누어서 동시에 처리**하는 작업이다. `innodb_parallel_read_threads` 시스템 변수를 이용해서 하나의 쿼리를 처리할 최대 스레드의 개수를 설정한다. 일반적으로 스레드의 개수가 늘어날수록 쿼리의 실행 시간을 줄어들지만, CPU 코어의 개수를 넘으면 성능이 떨어질 수 있다.

병렬 처리는 MySQL 8.0부터 제한적으로 도입되었다. WHERE 조건이 없는 테이블 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

### 정렬(ORDER BY) 처리

<small style="color: grey;">정렬 처리 방법 비교</small>

정렬을 처리하는 방법은 `인덱스를 이용한 방법`과 `Filesort를 이용한 방법`으로 구분한다.

`인덱스를 이용한 방법`은 정렬 작업을 빠르게 처리할 수 있다. 인덱스는 정렬된 상태로 디스크에 저장되어 있기 때문이다. 하지만 데이터를 추가, 변경, 삭제할 때 인덱스를 같이 관리해야 한다.

반면 `Filesort를 이용한 방법`은 인덱스에 의존하지 않는다. 모든 정렬 작업이 인덱스를 이용하는 방법으로 처리되지 않는다. 하지만 정렬 작업이 쿼리 실행 시 처리되기 때문에 정렬할 레코드가 많으면 쿼리 응답 속도가 느려진다.

<small style="color: grey;">소트 버퍼(Sort buffer)</small>

`소트 버퍼(Sort buffer)` 정렬 작업을 위해 MySQL이 별도로 할당한 메모리 공간이다. 정렬할 레코드 크기에 따라서 가변적으로 증가하지만 최대 사용 크기는 `sort_buffer_size` 시스템 변수로 설정된다.

메모리(소트 버퍼)의 크기를 넘어서는 데이터를 정렬하기 위해서는 디스크 공간도 활용된다. 소트 버퍼 크기만큼 정렬된 데이터를 디스크에 임시 저장한다. 디스크에 임시 정렬 저장된 데이터를 다시 병합하면서 정렬하는 `멀티 머지(Multi-merge)`를 수행한다. 

메모리(소트 버퍼)의 크기를 키우며 디스크 IO를 줄일 수 있다. 하지만, 성능 상에 큰 이점을 보기는 어렵다. 심지어 메모리(소트 버퍼) 공간이 커지면서 OOM이 발생할 수 있다. 소트 버퍼는 세션 메모리 영역을 사용하기 때문에 모든 커넥션마다 소트 버퍼 메모리 공간이 할당된다. 커넥션이 많아지고 각 커넥션마다 정렬해야 하는 데이터의 크기가 크면, 소트 버퍼의 크기로 인해 서버의 메모리 공간이 부족하게 된다.

<small style="color: grey;">정렬 방식</small>

정렬 방식은 소트 버퍼에 어떠한 레코드가 저장되는지에 따라서 `싱글 패스 방식`과 `투 패스 방식`으로 구분한다.

`싱글 패스 방식`은 소트 버퍼에 **정렬 기준이 되는 칼럼**과 **SELECT 대상이 되는 칼럼 전부**를 저장한다. 따라서 정렬이 이루어진 이후에 소트 버퍼에 있는 레코드를 반환하면 된다.

`투 패스 방식`은 소트 버퍼에 **정렬 기준이 되는 칼럼**과 **프라이머리 키**를 저장한다. 정렬이 이루어진 이후에 프라이머리 키를 가지고 테이블을 다시 조회해서 반환한다. 

최신 버전에서는 일반적으로 싱글 패스 방식을 더 많이 사용한다. 하지만 싱글 패스 방식은 소트 버퍼 크기에 의존적이다. 모든 칼럼(*)을 정렬 조회할 경우 소트 버퍼를 비효율적으로 점유할 가능성이 크다.

<small style="color: grey;">조인(JOIN) 쿼리와 제한(LIMIT) 쿼리에서 정렬</small>

조인된 테이블을 정렬할 때 정렬 기준 칼럼에 따라서 조인과 정렬 작업 방식이 달라진다. 정렬 기준 칼럼이 **드라이빙 테이블의 칼럼**이라면 드라이빙 테이블을 먼저 정렬하고 조인한다. 만약 정렬 기준 칼럼이 **드리븐 테이블의 칼럼**이라면 두 테이블을 조인한 임시 테이블을 만들고, 임시 테이블을 정렬한다. 일반적으로 조인을 하면 레코드의 개수가 급증한다. 드라이빙 테이블의 칼럼을 정렬 기준으로 사용하는 작업은 상대적으로 적은 레코드를 정렬하므로 작업 실행이 상대적으로 빠르다.

정렬 작업은 제한(LIMIT) 쿼리와 함께 종종 사용된다. 인덱스 정렬을 할 수 있을 때 제한 쿼리는 효과적이다. 인덱스 정렬은 실제로 정렬이 필요하지 않다. 따라서 제한 쿼리를 인덱스 정렬에 사용하면 필요한 소수의 데이터만을 읽기 때문에 효과적이다. 하지만, 인덱스 정렬을 사용할 수 없는 경우라면 정렬 작업이 우선적으로 이루어져야 한다. 이러한 경우 제한 쿼리를 실행했음에도 불구하고 작업이 오래 걸릴 수 있다.

결론적으로 정렬 기준은 인덱스가 있는 칼럼으로 하는 것이 좋다. 테이블 조인이 필요한 경우 정렬 기준은 드라이빙 테이블의 칼럼 값으로 설정하는 것이 좋다.

성능 비교를 위해 다음과 같은 상황을 생각한다. tb_test1 테이블의 레코드가 100건이고, tb_test2 테이블의 레코드가 1,000건이 있다고 가정한다. 또한 tb_test1 테이블의 레코드 1건당 tb_test2 테이블의 레코드가 10건씩 존재하여서 두 테이블 조인 결과는 전체 1,000건이다. 이러한 상황에서 정렬, 조인, LIMT에 따른 성능을 비교하면 다음과 같다.

```sql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1 = t2.col1
ORDER BY t1.col2
LIMIT 10
```

tb_test1이 드라이빙되는 경우
|정렬 방법|읽어야 할 건수|조인 횟수|정렬해야 할 대상 건수|
|-------|-----------|-------|---------------|
|인덱스 사용|tb_test1: 1건<br/>tb_test2: 10건|1번|0건|
|조인의 드라이빙 테이블만 정렬|tb_test1: 100건<br/>tb_test2: 10건|1번|100건|
|임시 테이블 사용 후 정렬|tb_test1: 100건<br/>tb_test2: 1,000건|100번|1,000건|

tb_test2가 드라이빙되는 경우
|정렬 방법|읽어야 할 건수|조인 횟수|정렬해야 할 대상 건수|
|-------|-----------|-------|---------------|
|인덱스 사용|tb_test1: 10건<br/>tb_test2: 10건|10번|0건|
|조인의 드라이빙 테이블만 정렬|tb_test1: 10건<br/>tb_test2: 1,000건|10번|1,000건|
|임시 테이블 사용 후 정렬|tb_test1: 100건<br/>tb_test2: 1,000건|1,000번|1,000건|

<small style="color: grey;">MySQL 정렬 상태 변수</small>

정렬 작업과 관련된 상태 변수는 다음과 같다.
- `Sort_merge_passes`: 멀티 머지 처리 횟수
- `Sort_range`: 인덱스 레인지 스캔을 사용한 정렬 작업 횟수
- `Sort_rows`: 풀 테이블 스캔을 사용한 정렬 작업 횟수
- `Sort_scan`: 지금까지 정렬한 전체 레코드 건수

### 그룹핑(GROUP BY) 처리

그룹핑(GROUP BY) 작업을 처리하는 방식은 인덱스 사용에 따라서 다음과 같이 나눌 수 있다.

1. `타이트 인덱스 스캔`을 활용한 그룹핑: GROUP BY의 기준이 되는 칼럼으로 인덱스가 설정되었다면, 인덱스를 차례대로 읽어서 그룹핑한다.

2. `루스 인덱스 스캔`을 활용한 그룹핑: 인덱스를 건너띄면서 필요한 부분만 읽어 그룹핑한다. 예를 들어 인덱스는 (col1, col2)로 설정되어 있고 GROUP BY의 기준은 col1 인 경우, 중복되지 않은 col1을 찾도록 인덱스를 건너띄면서 그룹핑한다.

3. `임시 테이블`을 활용한 그룹핑: 인덱스를 활용할 수 없는 경우 임시 테이블을 만들어서 그룹핑한다. 임시 테이블은 내부적으로 생성되며, GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진다.

### 고윳값(DISTINCT) 처리

DISTINCT 키워드는 집합 함수의 유무에 따라서 영향을 미치는 범위가 다르다. 

집합 함수를 사용하지 않는 경우 DISTINCT는 **고유한 레코드**를 가져온다. 예를 들어 `SELECT DISTINCT fist_name, last_name FROM employees` 쿼리에서 DISTINCT는 (first_name, last_name) 조합이 고유한 레코드를 선택한다.

집합 함수를 사용하는 경우 DISTINCT는 **고유한 칼럼의 값**을 가져온다. 집합 함수(ex, MIN, MAX)는 고유한 칼럼의 값에 적용한다. 칼럼에 인덱스가 있는지에 따라서 고유한 칼럼의 값을 가져오는 방식이 다르다. 칼럼에 인덱스가 있다면 인덱스 스캔을 통해 고유한 값을 반환할 수 있다. 칼럼에 인덱스가 없다면, 해당 칼럼에 대해서 유니크 인덱스를 가진 임시 테이블이 만들어진다.

### 내부 임시 테이블 활용

정렬, 그룹핑, 고윳값 처리를 위해서 내부적으로 임식 테이블이 만들어질 수 있다. 임시 테이블은 기본적으로는 메모리에 만들어졌다가 쿼리 실행이 완료되면 사라진다. 임시 테이블의 크기가 `temptable_max_ram` 시스템 변수에 설정된 값을 넘으면 디스크로 기록된다. 디스크에 저장될 때에는 MMAP 파일로 기록하는 방식과 InnoDB 테이블로 기록하는 방식이 있다. MMAP 파일로 기록하는 것이 오버헤드가 적으며, `temptable_use_mmap`
의 값을 ON으로 설정하면 된다.

### 옵티마이저 스위치 옵션

옵티마이저 스위치 옵션은 MySQL 서버의 고급 최적화 기능을 제어하는 시스템 변수이다. 옵티마이저 스위치 옵션으로 제어할 수 있는 기능은 다음과 같다.

|옵티마이저 스위치 이름|기본값|제어하는 최적화 기능|
|-----------------|----|---------------|
|`batched_key_access`|off|BKA 조인 알고리즘|
|`blocked_nested_loop`|on|Blocked Nested Loop 조인 알고리즘|
|`engine_condition_pushdown`|on|Engine Condition Pushdown 기능|
|`index_condition_pushdown`|on|Index Condition Pushdown 기능|
|`use_index_extensions`|on|Index Extension 최적화|
|`index_merge`|on|Index Merge 최적화|
|`index_merge_intersection`|on|Index Merge Intersection 최적화|
|`index_merge_sort_union`|on|Index Merge Sort Union 최적화|
|`index_merge_union`|on|Index Merge Sort Union 최적화|
|`mrr`|on|MRR 최적화|
|`mrr_cost_based`|on|비용 기반 MRR 최적화|
|`semijoin`|on|세미 조인|
|`firstmatch`|on|FirstMatch 세미 조인|
|`loosescan`|on|LooseScan 세민 조인|
|`materialization`|on|Materialization과 Materialization 세미 조인|
|`subquery_materialization_cost_based`|on|비용 기반 Materialization|

<small style="color: grey;">MRR과 BKA(Batched Key Access) 조인</small>

일반적으로 조인 작업은 드라이빙 테이블의 레코드를 한 개 읽고, 조건에 맞는 레코드를 드리븐 테이블에서 찾는다. 조인 처리는 MySQL 엔진에서 하지만 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진에서 처리한다. 드라이빙 테이블의 레코드 건별로 드리븐 테이블에서 레코드를 찾는 것은 비효율적이다.

MRR(Multi-Range Read)는 스토리지 엔진의 작업을 최적화한다. 드라이빙 테이블의 레코드와 조인될 레코드를 드리븐 테이블에서 바로 찾지 않는다. 대신 드라이빙 테이블의 레코드를 조인 버퍼에 버퍼링 한다. 조인 버퍼에 레코드가 차면, 드리븐 테이블에서 읽어야 할 레코드를 정렬된 순서로 한 번에 접근하도록 최적화한다. 이러한 MRR 방식을 응용한 조인 방식을 BKA(Batched Key Access)라고 부른다.

